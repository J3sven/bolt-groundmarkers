<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instance Layouts</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: rgba(20, 20, 25, 0.95);
            color: #e0e0e0;
            padding: 20px;
            overflow-y: auto;
            max-height: 100vh;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .subtitle {
            font-size: 14px;
            color: #999;
            margin-bottom: 20px;
        }

        .status-bar {
            background: rgba(40, 40, 50, 0.8);
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 20px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .status-row:last-child {
            margin-bottom: 0;
        }

        .status-label {
            color: #999;
            font-size: 13px;
        }

        .status-value {
            color: #00d4ff;
            font-weight: 600;
            font-size: 13px;
        }

        .status-value.warning {
            color: #ffaa00;
        }

        .section {
            background: rgba(30, 30, 40, 0.9);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #00d4ff;
        }

        .save-layout {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        input[type="text"] {
            flex: 1;
            padding: 10px 12px;
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
            outline: none;
        }

        input[type="text"]:focus {
            border-color: #00d4ff;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.1);
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #00a8cc, #00d4ff);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        button:hover {
            background: linear-gradient(135deg, #008fb3, #00bfe6);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: rgba(60, 60, 70, 0.5);
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        button.danger {
            background: linear-gradient(135deg, #cc3300, #ff4444);
        }

        button.danger:hover {
            background: linear-gradient(135deg, #b32d00, #e63939);
        }

        .layout-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .layout-item {
            background: rgba(40, 40, 50, 0.6);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s;
        }

        .layout-item:hover {
            background: rgba(50, 50, 60, 0.8);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .layout-item.active {
            background: rgba(0, 212, 255, 0.15);
            border-color: #00d4ff;
        }

        .layout-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .layout-name {
            font-weight: 600;
            font-size: 15px;
            color: #fff;
        }

        .layout-item.active .layout-name {
            color: #00d4ff;
        }

        .layout-info {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
        }

        .layout-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .layout-actions button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .view-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .view-toggle button {
            flex: 1;
            padding: 10px 0;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #bbb;
        }

        .view-toggle button.active {
            background: linear-gradient(135deg, #00a8cc, #00d4ff);
            color: #fff;
            border-color: rgba(0, 212, 255, 0.6);
        }

        .view-panel {
            display: none;
        }

        .view-panel.active {
            display: block;
        }

        .chunk-grid-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chunk-grid-meta {
            font-size: 12px;
            color: #aaa;
        }

        .chunk-grid {
            display: grid;
            grid-template-columns: repeat(64, minmax(0, 1fr));
            gap: 1px;
            width: 100%;
            max-width: 520px;
            margin: 0 auto;
            padding: 8px;
            background: rgba(15, 15, 25, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .chunk-grid .grid-cell {
            aspect-ratio: 1 / 1;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 2px;
            transition: background 0.15s ease, transform 0.1s ease;
        }

        .chunk-grid .grid-cell.marked {
            background: rgba(0, 212, 255, 0.6);
        }

        .chunk-grid .grid-cell.player {
            background: rgba(255, 170, 0, 0.8);
        }

        .chunk-grid .grid-cell.hover {
            outline: 1px solid #fff;
            background: rgba(255, 255, 255, 0.7);
        }

        .chunk-grid-disabled .chunk-grid {
            opacity: 0.35;
            pointer-events: none;
        }

        .chunk-grid-legend {
            display: flex;
            gap: 16px;
            justify-content: center;
            font-size: 12px;
            color: #aaa;
        }

        .chunk-grid-legend span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .legend-swatch {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            display: inline-block;
        }

        .legend-swatch.marked {
            background: rgba(0, 212, 255, 0.8);
        }

        .legend-swatch.player {
            background: rgba(255, 170, 0, 0.9);
        }

        .legend-swatch.hover {
            background: rgba(255, 255, 255, 0.9);
        }

        .chunk-grid-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .chunk-grid-controls label {
            font-size: 12px;
            color: #aaa;
            min-width: 90px;
        }

        select {
            flex: 1;
            padding: 6px 10px;
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 13px;
        }

        .palette-editor {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .palette-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            flex-wrap: wrap;
        }

        .palette-color-preview {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .palette-fields {
            display: flex;
            gap: 10px;
            flex: 1;
            flex-wrap: wrap;
        }

        .palette-fields label {
            display: flex;
            flex-direction: column;
            font-size: 11px;
            color: #aaa;
            gap: 4px;
        }

        .palette-fields input[type="text"] {
            width: 180px;
        }

        .palette-fields input[type="color"] {
            width: 60px;
            height: 34px;
            padding: 0;
            border: none;
            background: transparent;
        }

        .palette-save {
            padding: 8px 14px;
            font-size: 12px;
        }

        .palette-empty {
            text-align: center;
            font-size: 13px;
            color: #888;
        }

        .toggle-switch {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }

        .toggle-switch input {
            display: none;
        }

        .toggle-track {
            position: relative;
            width: 42px;
            height: 22px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 999px;
            transition: background 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .toggle-track::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.2s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        .toggle-switch input:checked + .toggle-track {
            background: linear-gradient(135deg, #00a8cc, #00d4ff);
            border-color: rgba(0, 212, 255, 0.5);
        }

        .toggle-switch input:checked + .toggle-track::after {
            transform: translateX(20px);
        }

        .toggle-label {
            font-size: 12px;
            color: #999;
            min-width: 48px;
        }

        .toggle-switch input:checked ~ .toggle-label {
            color: #00d4ff;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.3;
        }

        .help-text {
            font-size: 13px;
            color: #888;
            line-height: 1.5;
            background: rgba(255, 200, 0, 0.1);
            padding: 12px;
            border-radius: 4px;
            border-left: 3px solid #ffaa00;
        }

        .close-button {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 32px;
            height: 32px;
            padding: 0;
            background: rgba(255, 68, 68, 0.8);
            border-radius: 50%;
            font-size: 18px;
            line-height: 32px;
            text-align: center;
        }

        .close-button:hover {
            background: rgba(255, 68, 68, 1);
        }
    </style>
</head>
<body>
    <button class="close-button" onclick="closeWindow()">√ó</button>

    <div class="container">
        <h1>Instance Tile Layouts</h1>
        <p class="subtitle">Manage saved tile marker layouts for instances</p>

        <div class="status-bar">
            <div class="status-row">
                <span class="status-label">Status:</span>
                <span class="status-value" id="instance-status">Not in Instance</span>
            </div>
            <div class="status-row">
                <span class="status-label">Unsaved Tiles:</span>
                <span class="status-value" id="temp-tiles">0</span>
            </div>
            <div class="status-row">
                <span class="status-label">Active Layout:</span>
                <span class="status-value" id="active-layout">None</span>
            </div>
        </div>

        <div class="view-toggle">
            <button class="view-button active" data-view="layouts">Layouts</button>
            <button class="view-button" data-view="chunk">Chunk Map</button>
            <button class="view-button" data-view="palette">Palette</button>
        </div>

        <div id="view-layouts" class="view-panel active">
            <div class="section" id="save-section">
                <div class="section-title">Save Current Tiles</div>
                <p class="help-text" id="save-help">
                    Mark tiles in an instance, then save them as a named layout here.
                </p>
                <div class="save-layout">
                    <input type="text" id="layout-name" placeholder="Enter layout name (e.g., 'Croesus', 'ED3 Boss 1')">
                    <button onclick="saveLayout()" id="save-button" disabled>Save Layout</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Saved Layouts</div>
                <div class="layout-list" id="layout-list">
                    <div class="empty-state">
                        <div class="empty-state-icon">üìç</div>
                        <p>No saved layouts yet</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="view-chunk" class="view-panel">
            <div class="section chunk-grid-disabled" id="chunk-grid-section">
                <div class="section-title">Chunk Grid Map</div>
                <p class="help-text" id="chunk-grid-help">
                    Loading chunk information...
                </p>
                <div class="chunk-grid-wrapper">
                    <div class="chunk-grid-controls">
                        <label for="chunk-color-select">Marker Color</label>
                        <select id="chunk-color-select" disabled></select>
                    </div>
                    <div class="chunk-grid-meta" id="chunk-grid-meta">Chunk (--, --)</div>
                    <div class="chunk-grid" id="chunk-grid"></div>
                    <div class="chunk-grid-legend">
                        <span><span class="legend-swatch player"></span>Player</span>
                        <span><span class="legend-swatch marked"></span>Marked</span>
                        <span><span class="legend-swatch hover"></span>Hover Preview</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="view-palette" class="view-panel">
            <div class="section">
                <div class="section-title">Custom Color Palette</div>
                <p class="help-text">
                    Adjust the colors used for markers and chunk editing. Changes apply immediately and sync with your layouts.
                </p>
                <div class="palette-editor" id="palette-editor">
                    <p class="palette-empty">Loading palette‚Ä¶</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentState = {
            inInstance: false,
            tempTileCount: 0,
            activeLayoutId: null,
            layouts: [],
            chunkGrid: null,
            palette: [],
            currentColorIndex: 1
        };

        const chunkGridSection = document.getElementById('chunk-grid-section');
        const chunkGridContainer = document.getElementById('chunk-grid');
        const chunkGridHelp = document.getElementById('chunk-grid-help');
        const chunkGridMeta = document.getElementById('chunk-grid-meta');
        const chunkColorSelect = document.getElementById('chunk-color-select');
        const paletteEditor = document.getElementById('palette-editor');
        let chunkGridHoverKey = null;
        let chunkSelectedColorIndex = 1;
        const viewButtons = document.querySelectorAll('.view-button');
        const viewPanels = {
            layouts: document.getElementById('view-layouts'),
            chunk: document.getElementById('view-chunk'),
            palette: document.getElementById('view-palette')
        };
        let activeView = 'layouts';

        // Listen for messages from Lua
        // Bolt uses a custom message system
        window.addEventListener('message', function(event) {
            let data = event.data;

            // Handle Bolt's pluginMessage format with ArrayBuffer
            if (data && data.type === 'pluginMessage' && data.content instanceof ArrayBuffer) {
                const decoder = new TextDecoder();
                const jsonString = decoder.decode(data.content);
                try {
                    data = JSON.parse(jsonString);
                } catch (e) {
                    console.error('Failed to parse decoded message:', jsonString, e);
                    return;
                }
            }

            // Try parsing if it's a string
            let parsedData = data;
            if (typeof data === 'string') {
                try {
                    parsedData = JSON.parse(data);
                } catch (e) {
                    console.error('Failed to parse message:', data, e);
                    return;
                }
            }

            // Only log non-periodic updates to reduce spam
            if (parsedData.type !== 'state_update' || parsedData.debug) {
                console.log('Received:', parsedData.type, parsedData);
            }

            if (parsedData.type === 'state_update') {
                currentState = { ...currentState, ...parsedData };
                currentState.chunkGrid = parsedData.chunkGrid || null;
                currentState.palette = parsedData.palette || currentState.palette;
                currentState.currentColorIndex = parsedData.currentColorIndex || currentState.currentColorIndex || 1;
                syncChunkColorSelection();
                updateUI();
            } else if (parsedData.type === 'layouts_update') {
                currentState.layouts = parsedData.layouts || [];
                updateUI();
            }
        });

        function updateUI() {
            // Update status bar
            document.getElementById('instance-status').textContent =
                currentState.inInstance ? 'In Instance' : 'Not in Instance';
            document.getElementById('instance-status').className =
                'status-value' + (currentState.inInstance ? '' : ' warning');

            document.getElementById('temp-tiles').textContent = currentState.tempTileCount || 0;

            const activeLayout = currentState.layouts.find(l => l.id === currentState.activeLayoutId);
            document.getElementById('active-layout').textContent =
                activeLayout ? activeLayout.name : 'None';

            // Update save button state
            const saveButton = document.getElementById('save-button');
            const layoutNameInput = document.getElementById('layout-name');
            saveButton.disabled = !currentState.inInstance || currentState.tempTileCount === 0 || !layoutNameInput.value.trim();

            // Update help text
            if (!currentState.inInstance) {
                document.getElementById('save-help').textContent =
                    'Enter an instance and mark some tiles to save a layout.';
            } else if (currentState.tempTileCount === 0) {
                document.getElementById('save-help').textContent =
                    'Mark some tiles (Alt+MiddleClick) before saving.';
            } else {
                document.getElementById('save-help').textContent =
                    `You have ${currentState.tempTileCount} temporary tile(s) ready to save.`;
            }

            // Update layouts list
            updateChunkGrid();
            updateChunkColorSelect();
            renderPaletteEditor();
            updateLayoutsList();
        }

        function updateLayoutsList() {
            const listContainer = document.getElementById('layout-list');

            if (currentState.layouts.length === 0) {
                listContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìç</div>
                        <p>No saved layouts yet</p>
                    </div>
                `;
                return;
            }

            listContainer.innerHTML = currentState.layouts.map(layout => {
                const isActive = layout.id === currentState.activeLayoutId;
                const tileCount = layout.tiles ? layout.tiles.length : 0;

                return `
                    <div class="layout-item ${isActive ? 'active' : ''}" data-id="${layout.id}">
                        <div class="layout-header">
                            <div class="layout-name">${escapeHtml(layout.name)}</div>
                        </div>
                        <div class="layout-info">
                            ${tileCount} tile${tileCount !== 1 ? 's' : ''}
                        </div>
                        <div class="layout-actions">
                            <label class="toggle-switch">
                                <input type="checkbox" ${isActive ? 'checked' : ''} onchange="toggleLayout('${layout.id}', this)">
                                <span class="toggle-track"></span>
                                <span class="toggle-label">${isActive ? 'Active' : 'Inactive'}</span>
                            </label>
                            <button class="danger" onclick="deleteLayout('${layout.id}', '${escapeHtml(layout.name)}')">Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function syncChunkColorSelection() {
            const palette = currentState.palette || [];
            if (palette.length === 0) {
                chunkSelectedColorIndex = 1;
                return;
            }

            const hasSelection = palette.some(entry => entry.index === chunkSelectedColorIndex);
            if (!hasSelection) {
                const fallback = palette.find(entry => entry.index === currentState.currentColorIndex) || palette[0];
                chunkSelectedColorIndex = fallback.index;
            }
        }

        function getSelectedChunkColorName() {
            const palette = currentState.palette || [];
            const found = palette.find(entry => entry.index === chunkSelectedColorIndex);
            return found ? found.name : `Color ${chunkSelectedColorIndex}`;
        }

        function getSelectedChunkColorCode() {
            const palette = currentState.palette || [];
            const found = palette.find(entry => entry.index === chunkSelectedColorIndex);
            return found ? found.hex : '#ffffff';
        }

        function updateChunkColorSelect() {
            if (!chunkColorSelect) {
                return;
            }

            const palette = currentState.palette || [];
            if (palette.length === 0) {
                chunkColorSelect.innerHTML = '<option>No colors available</option>';
                chunkColorSelect.disabled = true;
                return;
            }

            const optionsHtml = palette.map(entry => {
                const label = escapeHtml(entry.name || `Color ${entry.index}`);
                return `<option value="${entry.index}">${label}</option>`;
            }).join('');

            chunkColorSelect.innerHTML = optionsHtml;
            chunkColorSelect.disabled = false;
            chunkColorSelect.value = String(chunkSelectedColorIndex);
        }

        function renderPaletteEditor() {
            if (!paletteEditor) {
                return;
            }

            const palette = currentState.palette || [];
            if (palette.length === 0) {
                paletteEditor.innerHTML = '<p class="palette-empty">Palette unavailable.</p>';
                return;
            }

            paletteEditor.innerHTML = palette.map(entry => {
                const safeName = escapeHtml(entry.name || `Color ${entry.index}`);
                const hex = entry.hex || '#ffffff';
                return `
                    <div class="palette-row" data-index="${entry.index}">
                        <div class="palette-color-preview" style="background:${hex};"></div>
                        <div class="palette-fields">
                            <label>
                                Name
                                <input type="text" class="palette-name-input" value="${safeName}">
                            </label>
                            <label>
                                Color
                                <input type="color" class="palette-color-input" value="${hex}">
                            </label>
                        </div>
                        <button class="palette-save" data-index="${entry.index}">Save</button>
                    </div>
                `;
            }).join('');

            paletteEditor.querySelectorAll('.palette-save').forEach(button => {
                button.addEventListener('click', () => {
                    savePaletteEntry(Number(button.dataset.index));
                });
            });
        }

        function isChunkGridInteractive() {
            return currentState.chunkGrid && currentState.chunkGrid.enabled;
        }

        function resetChunkGridHover(shouldNotify) {
            const hadHover = !!chunkGridHoverKey;
            if (chunkGridContainer) {
                const active = chunkGridContainer.querySelector('.grid-cell.hover');
                if (active) {
                    active.classList.remove('hover');
                }
            }
            if (shouldNotify && hadHover) {
                sendToLua({ action: 'hover_chunk_tile', clear: true });
            }
            chunkGridHoverKey = null;
        }

        function savePaletteEntry(index) {
            if (!paletteEditor) {
                return;
            }

            const row = paletteEditor.querySelector(`.palette-row[data-index="${index}"]`);
            if (!row) {
                return;
            }

            const nameInput = row.querySelector('.palette-name-input');
            const colorInput = row.querySelector('.palette-color-input');
            if (!colorInput || !colorInput.value) {
                alert('Please pick a color.');
                return;
            }

            const hex = colorInput.value.trim();
            if (!/^#[0-9a-fA-F]{6}$/.test(hex)) {
                alert('Please provide a valid hex color.');
                return;
            }

            sendToLua({
                action: 'update_palette_color',
                index: index,
                name: nameInput ? nameInput.value.trim() : '',
                color: hex
            });
        }

        function updateChunkGrid() {
            if (!chunkGridSection || !chunkGridContainer) {
                return;
            }

            const gridData = currentState.chunkGrid;

            if (!gridData || typeof gridData.chunkX === 'undefined' || typeof gridData.chunkZ === 'undefined') {
                chunkGridSection.classList.add('chunk-grid-disabled');
                chunkGridContainer.innerHTML = '';
                if (chunkGridMeta) {
                    chunkGridMeta.textContent = 'Chunk (--, --)';
                }
                if (chunkGridHelp) {
                    chunkGridHelp.textContent = 'Chunk information unavailable.';
                }
                resetChunkGridHover(true);
                return;
            }

            const enabled = !!gridData.enabled;
            chunkGridSection.classList.toggle('chunk-grid-disabled', !enabled);

            if (chunkGridHelp) {
                if (enabled) {
                    const modeLabel = gridData.mode === 'instance'
                        ? 'Instance temporary tiles'
                        : 'Tile markers';
                    const colorLabel = getSelectedChunkColorName();
                    const colorCode = getSelectedChunkColorCode();
                    chunkGridHelp.innerHTML = `Editing ${modeLabel} using <span style="color: ${colorCode}">${colorLabel}</span>. Hover to preview tiles, click to mark/unmark, and scroll over a marked tile to adjust its height. Orange shows where you stand.`;
                } else {
                    chunkGridHelp.textContent = 'Chunk information unavailable.';
                }
            }

            if (chunkGridMeta) {
                const chunkLabel = `Chunk (${gridData.chunkX}, ${gridData.chunkZ})`;
                let localLabel = 'Local (--, --)';
                if (typeof gridData.playerLocalX === 'number' && typeof gridData.playerLocalZ === 'number') {
                    localLabel = `Local (${gridData.playerLocalX}, ${gridData.playerLocalZ})`;
                }
                const modeLabel = gridData.mode === 'instance' ? 'Instance Tiles' : 'World Markers';
                chunkGridMeta.textContent = `${chunkLabel} ‚Ä¢ ${localLabel} ‚Ä¢ ${modeLabel}`;
            }

            if (!enabled) {
                chunkGridContainer.innerHTML = '';
                resetChunkGridHover(true);
                return;
            }

            const size = gridData.size || 64;
            const marked = gridData.marked || [];
            const markedSet = new Set(
                marked
                    .filter(tile => typeof tile.localX === 'number' && typeof tile.localZ === 'number')
                    .map(tile => `${tile.localX},${tile.localZ}`)
            );

            let html = '';
            for (let displayZ = 0; displayZ < size; displayZ++) {
                const localZ = size - 1 - displayZ;
                for (let localX = 0; localX < size; localX++) {
                    const key = `${localX},${localZ}`;
                    const classes = ['grid-cell'];
                    if (markedSet.has(key)) {
                        classes.push('marked');
                    }
                    if (gridData.playerLocalX === localX && gridData.playerLocalZ === localZ) {
                        classes.push('player');
                    }
                    if (chunkGridHoverKey === key) {
                        classes.push('hover');
                    }
                    html += `<div class="${classes.join(' ')}" data-local-x="${localX}" data-local-z="${localZ}"></div>`;
                }
            }

            chunkGridContainer.innerHTML = html;
        }

        function handleChunkGridHover(event) {
            if (!isChunkGridInteractive()) {
                return;
            }

            const cell = event.target.closest('.grid-cell');
            if (!cell || !chunkGridContainer.contains(cell)) {
                return;
            }

            const key = `${cell.dataset.localX},${cell.dataset.localZ}`;
            if (key === chunkGridHoverKey) {
                return;
            }

            const active = chunkGridContainer.querySelector('.grid-cell.hover');
            if (active) {
                active.classList.remove('hover');
            }

            chunkGridHoverKey = key;
            cell.classList.add('hover');

            sendToLua({
                action: 'hover_chunk_tile',
                localX: Number(cell.dataset.localX),
                localZ: Number(cell.dataset.localZ)
            });
        }

        function handleChunkGridLeave() {
            if (!chunkGridHoverKey) {
                return;
            }
            resetChunkGridHover(true);
        }

        function handleChunkGridClick(event) {
            if (!isChunkGridInteractive()) {
                return;
            }

            const cell = event.target.closest('.grid-cell');
            if (!cell || !chunkGridContainer.contains(cell)) {
                return;
            }

            sendToLua({
                action: 'toggle_chunk_tile',
                localX: Number(cell.dataset.localX),
                localZ: Number(cell.dataset.localZ),
                scope: currentState.chunkGrid ? currentState.chunkGrid.mode : null,
                colorIndex: chunkSelectedColorIndex
            });
        }

        function handleChunkGridWheel(event) {
            if (!isChunkGridInteractive()) {
                return;
            }

            const cell = event.target.closest('.grid-cell');
            if (!cell || !chunkGridContainer.contains(cell)) {
                return;
            }

            if (!cell.classList.contains('marked')) {
                return;
            }

            if (!event.deltaY) {
                return;
            }

            event.preventDefault();

            const direction = event.deltaY > 0 ? -1 : 1;

            sendToLua({
                action: 'adjust_chunk_tile_height',
                localX: Number(cell.dataset.localX),
                localZ: Number(cell.dataset.localZ),
                direction: direction,
                scope: currentState.chunkGrid ? currentState.chunkGrid.mode : null
            });
        }

        function saveLayout() {
            const name = document.getElementById('layout-name').value.trim();
            if (!name) {
                alert('Please enter a layout name');
                return;
            }

            if (!currentState.inInstance) {
                alert('You must be in an instance to save a layout');
                return;
            }

            if (currentState.tempTileCount === 0) {
                alert('No tiles to save. Mark some tiles first.');
                return;
            }

            console.log('Saving layout:', name);

            // Send to Lua via bolt-api
            sendToLua({
                action: 'save_layout',
                name: name
            });

            // Clear input
            document.getElementById('layout-name').value = '';
        }

        function activateLayout(layoutId) {
            if (!currentState.inInstance) {
                alert('You must be in an instance to activate a layout');
                return false;
            }

            if (currentState.activeLayoutId === layoutId) {
                return true;
            }

            currentState.activeLayoutId = layoutId;
            updateUI();

            sendToLua({
                action: 'activate_layout',
                layoutId: layoutId
            });

            return true;
        }

        function deactivateLayout() {
            if (!currentState.activeLayoutId) {
                return false;
            }

            currentState.activeLayoutId = null;
            updateUI();

            sendToLua({
                action: 'deactivate_layout'
            });

            return true;
        }

        function deleteLayout(layoutId, layoutName) {
            if (confirm(`Delete layout "${layoutName}"?`)) {
                sendToLua({
                    action: 'delete_layout',
                    layoutId: layoutId
                });
            }
        }

        function toggleLayout(layoutId, checkboxEl) {
            if (checkboxEl.checked) {
                const success = activateLayout(layoutId);
                if (!success) {
                    checkboxEl.checked = false;
                }
            } else {
                if (currentState.activeLayoutId === layoutId) {
                    deactivateLayout();
                } else {
                    checkboxEl.checked = true;
                }
            }
        }

        function switchView(targetView) {
            if (!targetView || targetView === activeView || !viewPanels[targetView]) {
                return;
            }

            viewButtons.forEach(button => {
                button.classList.toggle('active', button.dataset.view === targetView);
            });

            Object.entries(viewPanels).forEach(([name, panel]) => {
                if (panel) {
                    panel.classList.toggle('active', name === targetView);
                }
            });

            activeView = targetView;

            if (activeView !== 'chunk') {
                resetChunkGridHover(true);
            }
        }

        function closeWindow() {
            sendToLua({
                action: 'close'
            });
        }

        // Helper function to send messages to Lua via bolt-api
        function sendToLua(data) {
            fetch('https://bolt-api/send-message', {
                method: 'POST',
                body: JSON.stringify(data)
            }).then(() => {
                console.log('Sent to Lua:', data);
            }).catch((error) => {
                console.error('Failed to send to Lua:', error);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        if (chunkGridContainer) {
            chunkGridContainer.addEventListener('mouseover', handleChunkGridHover);
            chunkGridContainer.addEventListener('mouseleave', handleChunkGridLeave);
            chunkGridContainer.addEventListener('click', handleChunkGridClick);
            chunkGridContainer.addEventListener('wheel', handleChunkGridWheel, { passive: false });
        }

        if (chunkColorSelect) {
            chunkColorSelect.addEventListener('change', () => {
                const parsed = Number(chunkColorSelect.value);
                if (!Number.isNaN(parsed)) {
                    chunkSelectedColorIndex = parsed;
                    updateChunkGrid();
                }
            });
        }

        viewButtons.forEach(button => {
            button.addEventListener('click', () => {
                const target = button.dataset.view;
                switchView(target);
            });
        });

        // Enable/disable save button based on input
        document.getElementById('layout-name').addEventListener('input', function() {
            updateUI();
        });

        // Request initial state
        sendToLua({ action: 'ready' });
    </script>
</body>
</html>
